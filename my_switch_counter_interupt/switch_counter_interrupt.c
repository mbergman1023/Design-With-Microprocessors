#include <stdint.h>
#include <stdbool.h>
#include "inc/tm4c123gh6pm.h"
#include "driverlib/sysctl.h"

#define PF13 (*((volatile unsigned long*) 0x40025028))
//*****************************************************************************
//
//!
//! Design a counter. The counter is incremented by 1 when SW1 (PF4) or SW2 (PF0) 
//! is pressed.
//
//*****************************************************************************

// global variable visible in Watch window of debugger
// increments at least once per button press
volatile unsigned long count = 0;


void
PortFunctionInit(void)
{

		volatile uint32_t ui32Loop;   
	
		// Enable the clock of the GPIO port that is used for the on-board LED and switch.
    SYSCTL_RCGC2_R = SYSCTL_RCGC2_GPIOF;

    //
    // Do a dummy read to insert a few cycles after enabling the peripheral.
    //
    ui32Loop = SYSCTL_RCGC2_R;

		// Unlock GPIO Port F
		GPIO_PORTF_LOCK_R = 0x4C4F434B;   
		GPIO_PORTF_CR_R |= 0x01;           // allow changes to PF0

	
		// Set the direction of PF4 (SW1) and PF0 (SW2) as input by clearing the bit
    GPIO_PORTF_DIR_R &= ~0x11;
	
		GPIO_PORTF_DIR_R |= 0x0A; //set direction of PF3 and PF1 as output.
	
    // Enable PF4, PF3, PF1 and PF0 for digital function.
    GPIO_PORTF_DEN_R |= 0x1B;
		
		//GPIO_PORTF_DEN_R |= 0X0A;
	
		//Enable pull-up on PF4 and PF0
		GPIO_PORTF_PUR_R |= 0x11; 

}

//Globally enable interrupts 
void IntGlobalEnable(void)
{
    __asm("    cpsie   i\n");
}

//Globally disable interrupts 
void IntGlobalDisable(void)
{
    __asm("    cpsid   i\n");
}

void
Interrupt_Init(void)
{
  NVIC_EN0_R |= 0x40000000;  		// enable interrupt 30 in NVIC (GPIOF)// DATA SHEET PG 141
	NVIC_PRI7_R &= ~0x00E00000; 	// configure GPIOF interrupt priority as 0
	GPIO_PORTF_IM_R |= 0x11;   		// arm interrupt on PF0 and PF4
/*
	The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows
interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the
combined interrupt signal.

0 The interrupt from the corresponding pin is masked.
1 The interrupt from the corresponding pin is sent to the interrupt
controller.
	
	*/
	GPIO_PORTF_IS_R &= ~0x11;     // PF0 and PF4 are edge-sensitive
  /*The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures
the corresponding pin to detect levels, while clearing a bit configures the corresponding pin to detect
edges.
0 The edge on the corresponding pin is detected (edge-sensitive).
1 The level on the corresponding pin is detected (level-sensitive).

	*/
	GPIO_PORTF_IBE_R &= ~0x11;   	// PF0 and PF4 not both edges trigger DATA SHEET 658
/*The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the
GPIO Interrupt Sense (GPIOIS) register (see page 662) is set to detect edges, setting a bit in the
GPIOIBE register configures the corresponding pin to detect both rising and falling edges, regardless
of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register (see page 664). Clearing
a bit configures the pin to be controlled by the GPIOIEV register
0	Interrupt generation is controlled by the GPIO Interrupt Event
(GPIOIEV) register (see page 664).

1 Both edges on the corresponding pin trigger an interrupt.

	*/ 
	GPIO_PORTF_IEV_R &= ~0x11;  	// PF0 and PF4 falling edge event
	/*The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures
the corresponding pin to detect rising edges or high levels, depending on the corresponding bit
value in the GPIO Interrupt Sense (GPIOIS) register (see page 662). Clearing a bit configures the
pin to detect falling edges or low levels, depending on the corresponding bit value in the GPIOIS
register

0 falling edge or a Low level on the corresponding pin triggers
an interrupt. falling edge or a Low level on the corresponding pin triggers
an interrupt.	

1 rising edge or a High level on the corresponding pin triggers
an interrupt.

	*/
	
	IntGlobalEnable();  // globally enable interrupt
}

//interrupt handler
void GPIOPortF_Handler(void)
{
	//debounce by disabling interupt, waiting, then re-enabling it
	NVIC_EN0_R &= ~0x40000000; // disable interrupt 30 in NVIC (GPIOF)
	SysCtlDelay(74000);	// Delay for a while
	NVIC_EN0_R |= 0x40000000; // re-enable interrupt 30 in NVIC (GPIOF)

	if(GPIO_PORTF_RIS_R&0x10)//SW1 has action
	{
		GPIO_PORTF_ICR_R |= 0x10; // acknowledge flag for PF4
		// check for action instead of just checking for pin status to account for switch bouncing
		if((GPIO_PORTF_DATA_R&0x10)==0x00) //SW1 is pressed
		{
			count++;//counter imcremented by 1
			count &= 3; // keep count between 0-3
		}
	}
	
  if(GPIO_PORTF_RIS_R&0x01)//SW2 has action
	{
		GPIO_PORTF_ICR_R |= 0x01; // acknowledge flag for PF0
		
		if((GPIO_PORTF_DATA_R&0x01)==0x00) 
		{
			count--;//counter decremented by 1
			count &= 3;
		}
	}	
}

int main(void)
{
		
		PortFunctionInit();//initialize the GPIO ports	
				
		Interrupt_Init();//configure the GPIOF interrupt
	
    while(1)// Loop forever.
    {
			
			if(count == 0)
				PF13 = 0x00; // turn LEDs off
			else if(count == 1)
				PF13 = 0x02; // turn red LED on, green off
			else if(count == 2)
				PF13 = 0x08; //turn green LED on, red off
			else if(count == 3)
				PF13 = 0x0A;	//turn both on
			
    }
}
